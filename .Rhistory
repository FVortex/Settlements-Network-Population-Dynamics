temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centr_betw <- centr_betw(temp_graph, normalized = T)$centralization
}
# Quick explorative analysis:
# PopDynamics vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_betw, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop2002))+
# geom_smooth()+
geom_text(aes(x = centr_betw + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_betw, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_betw+0.001, y = variation_dif + 0.5,  label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_betw, y = variation_2002))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_betw+0.001, y = variation_2002 + 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_betw, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_betw+0.001, y = variation_dif + 0.5, label = clust_18))
# Создадим переменную
clusters_18_metrics$centr_clo <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centr_clo <- centr_betw(temp_graph, normalized = T)$centralization
}
# Quick explorative analysis:
# PopDynamics vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop2002))+
# geom_smooth()+
geom_text(aes(x = centr_betw + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
# Quick explorative analysis:
# PopDynamics vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y = centr_betw()))+
geom_point(aes(size = mean_pop2002))
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y = centr_betw))+
geom_point(aes(size = mean_pop2002))
# Создадим переменную
clusters_18_metrics$centr_clo <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centr_clo <- centr_clo(temp_graph, normalized = T)$centralization
}
# Quick explorative analysis:
# PopDynamics vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y = centr_betw))+
geom_point(aes(size = mean_pop2002))
# Quick explorative analysis:
# PopDynamics vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y =pop2010to2002_rel))+
geom_point(aes(size = mean_pop2002))+
# geom_smooth()+
geom_text(aes(x = centr_betw + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
# Quick explorative analysis:
# PopDynamics vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y =pop2010to2002_rel))+
geom_point(aes(size = mean_pop2002))+
# geom_smooth()+
geom_text(aes(x = centr_clo + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_betw+0.001, y = variation_dif + 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_clo+0.001, y = variation_dif + 0.5, label = clust_18))
View(clusters_18_metrics)
# 3.4.1. Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=dist2Tyumen/1000, y=pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000),
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика населения (%)")+
scale_x_continuous(name = "Расстояние от центра кластера (км)")
# 3.4.1. Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=dist2Tyumen/1000, y=pop2010to2002_rel))+
geom_point(aes(size = mean_pop2002))+
geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000),
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика населения (%)")+
scale_x_continuous(name = "Расстояние от центра кластера (км)")
# 3.4.1. Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=dist2Tyumen/1000, y=pop2010to2002_rel, col = centr_betw))+
geom_point(aes(size = mean_pop2002))+
geom_smooth(method = "glm")+
scale_color_viridis_c()+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000),
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика населения (%)")+
scale_x_continuous(name = "Расстояние от центра кластера (км)")
# 3.4.1. Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=dist2Tyumen/1000, y=pop2010to2002_rel, col = centr_clo))+
geom_point(aes(size = mean_pop2002))+
geom_smooth(method = "glm")+
scale_color_viridis_c()+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000),
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика населения (%)")+
scale_x_continuous(name = "Расстояние от центра кластера (км)")
# 3.4.1. Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=dist2Tyumen/1000, y=pop2010to2002_rel, col = density))+
geom_point(aes(size = mean_pop2002))+
geom_smooth(method = "glm")+
scale_color_viridis_c()+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000),
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика населения (%)")+
scale_x_continuous(name = "Расстояние от центра кластера (км)")
# 3.5.1. Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=dist2Tyumen/1000, y=pop2010to2002_rel, col = centr_betw))+
geom_point(aes(size = mean_pop2002))+
geom_smooth(method = "glm")+
scale_color_viridis_c()+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000),
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика населения (%)")+
scale_x_continuous(name = "Расстояние от центра кластера (км)")
# Создадим переменную
clusters_18_metrics$centr_betw <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centr_betw <- centr_betw(temp_graph, normalized = T)$centralization
}
# Quick explorative analysis:
# PopDynamics vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_betw, y =pop2010to2002_rel))+
geom_point(aes(size = mean_pop2002))+
# geom_smooth()+
geom_text(aes(x = centr_betw + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_betw, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_betw+0.001, y = variation_dif + 0.5, label = clust_18))
plot(temp_graph)
plot.igraph(temp_graph, mark.expand = centr_betw(temp_graph)$res)
plot.igraph(temp_graph, size = centr_betw(temp_graph)$res)
library(sp)
library(sf)
library(raster)
library(rgdal)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(igraph)
library(leaflet)
library(RColorBrewer)
library(tidyr)
library(scales)
library(ggdendro)   # визуализация дендрограмм
library(viridis)
# load the data
load("data/Part1_output.RData")
# 1.1.1 Models
# d_1990 <- as.dist(dist_matrix_1990, diag = F)
d_2002 <- as.dist(dist_matrix_2002, diag = F)
d_2010 <- as.dist(dist_matrix_2010, diag = F)
# fit_1990 <- hclust(d_1990, method="ward.D")
fit_2002 <- hclust(d_2002, method="ward.D")
fit_2010 <- hclust(d_2010, method="ward.D")
# Сut tree into 3 and 6 clusters
# clust_3_1990 <- cutree(fit_1990, k=3)
clust_3_2002 <- cutree(fit_2002, k=3)
clust_6_2002 <- cutree(fit_2002, k=6)
# Дополним точечный слой данными о принадлежности к кластерам
settlements_2002@data %>%
mutate(clust_3 = clust_3_2002,
clust_6 = clust_6_2002) -> settlements_2002@data
clust_18_2002 <- cutree(fit_2002, k = 18)
# Дополним точечный слой данными о принадлежности к кластерам
settlements_2002@data %>%
mutate(clust_18 = clust_18_2002) -> settlements_2002@data
# Сохраним данные в новую переменную и очистим от лишних столбцов
df <- settlements_2002@data
df %>%
select(-cohort1981, -cohort1990, -cohort2002,
-trend_1981to1990, -trend_1990to2002,
-rel1981to1990, -rel1990to2002, -rel2002to2010) -> df
df %>%
group_by(clust_18) %>%
mutate(pop2002 = sum(Census2002), pop2010 = sum(Census2010),
pop2010to2002_rel = pop2010/pop2002*100,         # отношение населения в 2010 году к населению в 2002
max_pop2002 = max(Census2002),                       # величина крупнешего н.п.
mean_pop2002 = mean(Census2002),                     # средний размер н.п.
median_pop2002 = median(Census2002),                 # медианный размер н.п.
sum_pop2002 = sum(Census2002)) %>%                   # сумма населения кластера
select(clust_6, clust_18, pop2002, pop2010, pop2010to2002_rel, mean_pop2002, median_pop2002, max_pop2002, sum_pop2002) %>%
unique() -> clusters_18_metrics                         # Сохраним результат в новый data.frame
# Создадим переменные
clusters_18_metrics$variation_2002 <- NA_real_
clusters_18_metrics$variation_2010 <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Calculate variation (standart deviation(x)/mean(x))
# 2002
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$variation_2002 <-
sd(settlements_temp$Census2002, na.rm = T)/mean(settlements_temp$Census2002, na.rm = T)
# 2010
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$variation_2010 <-
sd(settlements_temp$Census2010, na.rm = T)/mean(settlements_temp$Census2010, na.rm = T)
}
# Calculate the difference in variance between 2002 and 2010 (темпы сжатия расселения)
clusters_18_metrics %>%
mutate(variation_dif = variation_2010/variation_2002*100) ->
clusters_18_metrics
my_subgraph_function <- function(graph, nodes) {
# 1) сохраним в отдельный вектор номера всех вершин, лежащих между н.п.
# shortest_paths() возвращает именованный list длины @to,
# который содержит индексы всех вершин и ребер каждого пути
all_the_verticies <-
shortest_paths(graph = graph,        # igraph object
from = nodes,         # vertex ids from
to = nodes) %>%       # vertex ids to
.$vpath %>%                          # extract list of returned vertex ids
unlist()                             # unlist
# 2) выборка из графа
induced_subgraph(graph = graph,                        # igraph object
vids = all_the_verticies) %>%         # vertex ids
simplify() ->                                        # remove loop and multiple edges
sub_graph
return(sub_graph)
}
# Создадим переменную
clusters_18_metrics$density <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$density <- edge_density(temp_graph)
}
# Создадим переменную
clusters_18_metrics$centr_betw <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centr_betw <- centr_betw(temp_graph, normalized = T)$centralization
}
# Создадим переменную
clusters_18_metrics$centr_betw_U <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centr_betw_U <- centr_betw(temp_graph, directed = F, normalized = T)$centralization
}
# Quick explorative analysis:
# PopDynamics vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_betw, y =pop2010to2002_rel))+
geom_point(aes(size = mean_pop2002))+
# geom_smooth()+
geom_text(aes(x = centr_betw + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
# Quick explorative analysis:
# PopDynamics vs Density
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop2002))+
# geom_smooth()+
geom_text(aes(x = density + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
# Var_dif vs Density
clusters_18_metrics %>%
ggplot(aes(x = density, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = density+0.001, y = variation_dif + 0.5,  label = clust_18))
?centralization
centr_clo_tmax(10)
centr_clo_tmax(nodes = 10)
clust_18_2002
i <- 1
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
# Subset distance matrix: by row - cluster members, by column - Tyumen
temp_dist <- dist_matrix_2002[select_condition, select_condition]
temp_dist
res <- apply(temp_dist, MARGIN = 1, FUN = function(x) return(1/sum(x, na.rm = T)))
res
sum(max(res)-res)/centr_clo_tmax(nodes = length(res))
?closeness()
# # ======================
# # 4.2. Degree Centrality
# np_metrics$degree <- degree(graph = res_graph_2002, v = settl_index_2002)
#
# # ===========================
# # 4.2. Betweenness Centrality
#
# # Для рассчета BC нужно задать порог поиска (cutoff).
# # Рассчитаем его на основе средних расстояний между н.п. внутри 23 кластеров
#
clusters_18_metrics$centr_close_man <- NA_real_
for (i in 1:18) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
# Subset distance matrix: by row - cluster members, by column - Tyumen
temp_dist <- dist_matrix_2002[select_condition, select_condition]
res <- apply(temp_dist, MARGIN = 1, FUN = function(x) return(1/sum(x, na.rm = T)))
clusters_18_metrics[clusters_18_metrics$centr_close_man == i,]$mean_dist <- sum(max(res)-res)/centr_clo_tmax(nodes = length(res))
}
# # ======================
# # 4.2. Degree Centrality
# np_metrics$degree <- degree(graph = res_graph_2002, v = settl_index_2002)
#
# # ===========================
# # 4.2. Betweenness Centrality
#
# # Для рассчета BC нужно задать порог поиска (cutoff).
# # Рассчитаем его на основе средних расстояний между н.п. внутри 23 кластеров
#
clusters_18_metrics$centr_close_man <- NA_real_
for (i in 1:18) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
# Subset distance matrix: by row - cluster members, by column - Tyumen
temp_dist <- dist_matrix_2002[select_condition, select_condition]
res <- apply(temp_dist, MARGIN = 1, FUN = function(x) return(1/sum(x, na.rm = T)))
clusters_18_metrics[clusters_18_metrics$centr_close_man == i,]$centr_close_man <- sum(max(res)-res)/centr_clo_tmax(nodes = length(res))
}
for (i in 1:18) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
# Subset distance matrix: by row - cluster members, by column - Tyumen
temp_dist <- dist_matrix_2002[select_condition, select_condition]
res <- apply(temp_dist, MARGIN = 1, FUN = function(x) return(1/sum(x, na.rm = T)))
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centr_close_man <- sum(max(res)-res)/centr_clo_tmax(nodes = length(res))
}
View(clusters_18_metrics)
# Создадим переменную
clusters_18_metrics$centr_clo <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centr_clo <- centr_clo(temp_graph, normalized = T)$centralization
}
clusters_18_metrics %>%
ggplot(aes(x = centr_close_man, y = centr_clo))+
geom_point()
clusters_18_metrics %>%
ggplot(aes(x = centr_close_man, y = centr_clo, col = density))+
geom_point()
# Quick explorative analysis:
# PopDynamics vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_close_man, y =pop2010to2002_rel))+
geom_point(aes(size = mean_pop2002))+
# geom_smooth()+
geom_text(aes(x = centr_close_man + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
# Quick explorative analysis:
# PopDynamics vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_close_man, y =pop2010to2002_rel))+
geom_point(aes(size = mean_pop2002))+
# geom_smooth()+
geom_text(aes(y = pop2010to2002_rel - 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_close_man, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))
clusters_18_metrics %>%
ggplot(aes(x = centr_close_man, y = centr_clo, col = density))+
geom_point()
# Создадим переменную
clusters_18_metrics$centr_clo<- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centr_clo <- centr_clo(temp_graph, normalized = T)$centralization
}
# Quick explorative analysis:
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_close_man, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_betw+0.001, y = variation_dif + 0.5, label = clust_18))
# Quick explorative analysis:
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_betw, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_betw+0.001, y = variation_dif + 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_clo+0.001, y = variation_dif + 0.5, label = clust_18))
# Quick explorative analysis:
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_betw, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_betw+0.001, y = variation_dif + 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y = variation_dif, col = clust_6))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_clo+0.001, y = variation_dif + 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y = variation_dif, col = as.factor(clust_6)))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_clo+0.001, y = variation_dif + 0.5, label = clust_18))
# Quick explorative analysis:
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_betw, y = variation_dif, col = as.factor(clust_6)))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_betw+0.001, y = variation_dif + 0.5, label = clust_18))
# Var_dif vs Density
clusters_18_metrics %>%
ggplot(aes(x = density, y = variation_dif, col = as.factor(clust_6)))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = density+0.001, y = variation_dif + 0.5,  label = clust_18))
# Quick explorative analysis:
# PopDynamics vs Density
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel, col = as.factor(clust_6)))+
geom_point(aes(size = mean_pop2002))+
# geom_smooth()+
geom_text(aes(x = density + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = centr_clo, y = variation_dif))+
# geom_smooth()+
geom_point(aes(size = mean_pop2002))+
geom_text(aes(x = centr_clo+0.001, y = variation_dif + 0.5, label = clust_18))
cor(clusters_18_metrics$centr_close_man, clusters_18_metrics$centr_clo)
