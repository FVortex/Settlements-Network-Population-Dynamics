ggplot()+
geom_point(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w),
aes(x = x, y = y), alpha = 0.7)+
geom_smooth()
# В виде scatter plot
ggplot(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w),
aes(x = x, y = y))+
geom_point(alpha = 0.7)+
geom_smooth()
# В виде scatter plot
ggplot(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w),
aes(x = x, y = y))+
geom_point(alpha = 0.7)+
geom_smooth(method = "glm")
# В виде scatter plot - есть явный линейный тренд (!): чем ближе поселение к центру тяжести сети,
# тем выше его динамика населения
ggplot(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w),
aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
ggplot(data = data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w),
aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
ggplot(data = data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w),
aes(x = x, y = y))+
filter(y < 1000) %>%
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w) %>%
filter(y < 1000) %>%
ggplot(aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1981$rel1981to1990, x = closeness_1981_w) %>%
filter(y < 1000) %>%
ggplot(aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w) %>%
filter(y < 1000) %>%
ggplot(aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w) %>%
filter(y < 600) %>%
ggplot(aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w, size = settlements_1990$Rosstat1990) %>%
filter(y < 600) %>%
ggplot(aes(x = x, y = y))+
geom_point(aes(size = size), alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w, size = settlements_1990$Rosstat1990) %>%
# filter(y < 600) %>%
ggplot(aes(x = x, y = y))+
geom_point(aes(size = size), alpha = 0.6)+
geom_smooth(method = "glm")+
scale_y_continuous(trans = "log")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w, size = settlements_1990$Rosstat1990) %>%
filter(y < 600) %>%
ggplot(aes(x = x, y = y))+
geom_point(aes(size = size), alpha = 0.6)+
geom_smooth(method = "glm")
# В виде scatter plot - есть явный линейный тренд (!):
# чем ближе поселение к центру тяжести сети,
# тем выше его динамика населения
ggplot(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w,
size = settlements_2002$Census2002),
aes(x = x, y = y))+
geom_point(aes(size = size), alpha = 0.6)+
geom_smooth(method = "glm")
library(sp)
library(sf)
library(raster)
library(rgdal)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(igraph)
library(leaflet)
library(RColorBrewer)
library(tidyr)
library(scales)
library(ggdendro)   # визуализация дендрограмм
library(viridis)
# load the data
load("data/Part1_output.RData")
# 1.1.1 Models
# d_1990 <- as.dist(dist_matrix_1990, diag = F)
d_2002 <- as.dist(dist_matrix_2002, diag = F)
d_2010 <- as.dist(dist_matrix_2010, diag = F)
# fit_1990 <- hclust(d_1990, method="ward.D")
fit_2002 <- hclust(d_2002, method="ward.D")
fit_2010 <- hclust(d_2010, method="ward.D")
# Сut tree into 3 and 6 clusters
# clust_3_1990 <- cutree(fit_1990, k=3)
clust_3_2002 <- cutree(fit_2002, k=3)
clust_6_2002 <- cutree(fit_2002, k=6)
# Дополним точечный слой данными о принадлежности к кластерам
settlements_2002@data %>%
mutate(clust_3 = clust_3_2002,
clust_6 = clust_6_2002) -> settlements_2002@data
clust_18_2002 <- cutree(fit_2002, k = 18)
# Дополним точечный слой данными о принадлежности к кластерам
settlements_2002@data %>%
mutate(clust_18 = clust_18_2002) -> settlements_2002@data
# Сохраним данные в новую переменную и очистим от лишних столбцов
df <- settlements_2002@data
df %>%
group_by(clust_18) %>%
mutate(pop2002 = sum(Census2002), pop2010 = sum(Census2010),
pop2010to2002_rel = pop2010/pop2002*100,         # отношение населения в 2010 году к населению в 2002
max_pop = max(Census2002),                       # величина крупнешего н.п.
mean_pop = mean(Census2002),                     # средний размер н.п.
median_pop = median(Census2002),                 # медианный размер н.п.
sum_pop = sum(Census2002)) %>%                   # сумма населения кластера
select(clust_6, clust_18, pop2002, pop2010, pop2010to2002_rel, mean_pop,median_pop, max_pop, sum_pop) %>%
unique() -> clusters_18_metrics                         # Сохраним результат в новый data.frame
# Создадим переменные
clusters_18_metrics$variation_2002 <- NA_real_
clusters_18_metrics$variation_2010 <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Calculate variation (standart deviation(x)/mean(x))
# 2002
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$variation_2002 <-
sd(settlements_temp$Census2002, na.rm = T)/mean(settlements_temp$Census2002, na.rm = T)
# 2010
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$variation_2010 <-
sd(settlements_temp$Census2010, na.rm = T)/mean(settlements_temp$Census2010, na.rm = T)
}
# Calculate the difference in variance between 2002 and 2010 (темпы сжатия расселения)
clusters_18_metrics %>%
mutate(variation_dif = variation_2010/variation_2002*100) ->
clusters_18_metrics
# Темпы сжатия расселения vs общая динамика населения
clusters_18_metrics %>%
ggplot(aes(y=variation_dif, x=pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
# geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000), trans = "sqrt",
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика территориальной\nдифференциации расселения", breaks = seq(100, 115, 5),
limits = c(100,115))+
scale_x_continuous(name = "Динамика населения (%)")
clusters_18_metrics$dist2Tyumen <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Subset distance matrix: by row - cluster members, by column - Tyumen
distances_to_Tyumen <- dist_matrix_2002[select_condition, df$ShortName == "г. Тюмень"]
# Weight by population proportion
res <- sum(distances_to_Tyumen * settlements_temp$Census2002/sum(settlements_temp$Census2002))
# Save to res cell
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$dist2Tyumen <- res
}
# 3.4.1. Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=dist2Tyumen/1000, y=pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000),
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика населения (%)")+
scale_x_continuous(name = "Расстояние от центра кластера (км)")
# Lad the data
load("data/settlements.Rdata")
# Lad the data
load("data/settlements.Rdata")
library(sp)
library(sf)
library(raster)
library(rgdal)
library(dplyr)
library(ggplot2)
library(shp2graph)
library(igraph)
library(visNetwork)
# Создадим три набора точек по трем временным срезам,
# отфильтровав поселения: существовавшие на данный момент времени
np[np@data$Rosstat1990 > 0, ] -> settlements_1990
np[np@data$Census2002 > 0, ] -> settlements_2002
np[np@data$Census2010 > 0, ] -> settlements_2010
# Define the CRS
pulkovo1942.GK12 <- "+proj=tmerc +lat_0=0 +lon_0=69 +k=1 +x_0=12500000 +y_0=0 +ellps=krass +units=m +no_defs"
# Load rayouns borders from OSM and remove attributes except the names
rayons <- readOGR("data/MR_polygons.shp") %>% spTransform(CRS(pulkovo1942.GK12))
rayons@data %>% select(name) -> rayons@data
# TO_shapes
hydr_lines <- readOGR("data/Gidrology/Гидрография_линии.shp") %>%
geometry() %>%                                                # keep the geometry only
spTransform(CRS(pulkovo1942.GK12)) %>%
raster::intersect(region) -> hydr_lines
hydr_polygons <- readOGR("data/Gidrology/River_pols.shp") %>%
geometry() %>%                                                # keep the geometry only
spTransform(CRS(pulkovo1942.GK12)) %>%
raster::intersect(region) -> hydr_polygons
# Загрузим исправленный слой
roads_fixed <- readOGR("data/roads_fixed.shp")
# Удалим лишние столбцы
roads_fixed@data %>% select(-cat) -> roads_fixed@data
# 2.1. 1990 год
# Integrate settlements to graph
roads_points_temp <- points2network(ntdata = roads_fixed,            # roads layer
pointsxy = coordinates(settlements_1990),  # points ccordinates
ELComputed = T,                            # calculate and return the length of each edge
approach = 2,
ea.prop = c(0,1,1,1,1,1))                  # keep edge attributes
warnings()
roads_points_temp
# Convert to igraph object
res_graph_1990 <- nel2igraph(roads_points_temp[[1]],      # nodelist
roads_points_temp[[2]],           # edgelist
weight = roads_points_temp[[8]])  # the length of edges (from @ea.prop)
summary(res_graph_1990)
# Save node indexes, accotiated with settlements (we need them later)
settl_index_1990 <- roads_points_temp[[3]]
settl_index_1990
# 2.2. 2002 год
# Integrate settlements to graph
roads_points_temp <- points2network(ntdata = roads_fixed,                      # roads layer
pointsxy = coordinates(settlements_2002),  # points ccordinates
ELComputed = T,                            # calculate and return the length of each edge
approach = 2,
ea.prop = c(0,1,1,1,1,1))                  # keep edge attributes
# Convert to igraph object
res_graph_2002 <- nel2igraph(roads_points_temp[[1]],           # nodelist
roads_points_temp[[2]],           # edgelist
weight = roads_points_temp[[8]])  # the length of edges (from @ea.prop)
# Save node indexes, accotiated with settlements
settl_index_2002 <- roads_points_temp[[3]]
# 2.3. 2010 год
# Integrate settlements to graph
roads_points_temp <- points2network(ntdata = roads_fixed,                      # roads layer
pointsxy = coordinates(settlements_2010),  # points ccordinates
ELComputed = T,                            # calculate and return the length of each edge
approach = 2,
ea.prop = c(0,1,1,1,1,1))                  # keep edge attributes
# Convert to igraph object
res_graph_2010 <- nel2igraph(roads_points_temp[[1]],           # nodelist
roads_points_temp[[2]],           # edgelist
weight = roads_points_temp[[8]])  # the length of edges (from @ea.prop)
# Save node indexes, accotiated with settlements
settl_index_2010 <- roads_points_temp[[3]]
dist_matrix_1990 <-
shortest.paths(res_graph_1990,                                        # igraph object
v = settl_index_1990,                                  # from
# to: use the same indexes, but ordered
to = as.numeric(levels(as.factor(settl_index_1990))))
# Приведем матрицу в соответствие стандартному виду (диагональная ось = 0)
dist_matrix_1990 <- dist_matrix_1990[, match(settl_index_1990,
as.numeric(levels(as.factor(settl_index_1990))))]
# Check
dist_matrix_1990[1:10, 1:10]
# 2.4.2. 2002
dist_matrix_2002 <-
shortest.paths(res_graph_2002,                                        # igraph object
v = settl_index_2002,                                  # from
# to: use the same indexes, but ordered
to = as.numeric(levels(as.factor(settl_index_2002))))
# Приведем матрицу в соответствие стандартному виду (диагональная ось = 0)
dist_matrix_2002 <- dist_matrix_2002[, match(settl_index_2002,
as.numeric(levels(as.factor(settl_index_2002))))]
# 2.4.3. 2010
dist_matrix_2010 <-
shortest.paths(res_graph_2010,                                        # igraph object
v = settl_index_2010,                                  # from
# to: use the same indexes, but ordered
to = as.numeric(levels(as.factor(settl_index_2010))))
# Приведем матрицу в соответствие стандартному виду (диагональная ось = 0)
dist_matrix_2010 <- dist_matrix_2010[, match(settl_index_2010,
as.numeric(levels(as.factor(settl_index_2010))))]
# Удалим временные файлы и сохраним результат
rm(np, roads_points_temp, roads, road_topology_test)
save.image("data/Part1_output.RData")
# Lad the data
load("data/settlements.Rdata")
# Создадим три набора точек по трем временным срезам,
# отфильтровав поселения: существовавшие на данный момент времени
np[np@data$Rosstat1990 > 0, ] -> settlements_1990
library(sp)
library(sf)
library(raster)
library(rgdal)
library(dplyr)
library(ggplot2)
library(shp2graph)
library(igraph)
library(visNetwork)
# Создадим три набора точек по трем временным срезам,
# отфильтровав поселения: существовавшие на данный момент времени
np[np@data$Rosstat1990 > 0, ] -> settlements_1990
settlements_1990
# Создадим три набора точек по трем временным срезам,
# отфильтровав поселения: существовавшие на данный момент времени
np[np@data$Rosstat1990 >= 0, ] -> settlements_1990
settlements_1990
# Создадим три набора точек по трем временным срезам,
# отфильтровав поселения: существовавшие на данный момент времени
np[np@data$Rosstat1990 != 0 || np@data$Census2002 != 0, ] -> settlements_1990
settlements_1990
# Создадим три набора точек по трем временным срезам,
# отфильтровав поселения: существовавшие на данный момент времени
np[np@data$Rosstat1990 != 0 | np@data$Census2002 != 0, ] -> settlements_1990
settlements_1990
np[np@data$Census2002 != 0 | np@data$Census2010 != 0, ] -> settlements_2002
settlements_2002
?over
library(sp)  # Поддержка пространственных данных
library(rgdal) # Чтение и запись пространственных данных
library(classInt) # Классификация одномерных числовых рядов
library(rgeos) # Геометрические операции
library(osrm) # Использование онлайн-сервиса маршрутизации OSRM
library(cartography) # Удобное построение тематических карт средствами plot()
library(deldir) # Триангуляция Делоне
library(spatstat) # Анализ точечных распределенй
library(plotly) # Интерактивная графика
library(raster) # Работа с растрами
?over
library(sp)
library(sf)
library(raster)
library(rgdal)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(igraph)
library(leaflet)
library(RColorBrewer)
library(tidyr)
library(scales)
library(ggdendro)   # визуализация дендрограмм
library(viridis)
# load the data
load("data/Part1_output.RData")
# 1.1.1 Models
# d_1990 <- as.dist(dist_matrix_1990, diag = F)
d_2002 <- as.dist(dist_matrix_2002, diag = F)
d_2010 <- as.dist(dist_matrix_2010, diag = F)
# fit_1990 <- hclust(d_1990, method="ward.D")
fit_2002 <- hclust(d_2002, method="ward.D")
fit_2010 <- hclust(d_2010, method="ward.D")
clust_6_2002 <- cutree(fit_2002, k=6)
# Сut tree into 3 and 6 clusters
# clust_3_1990 <- cutree(fit_1990, k=3)
clust_3_2002 <- cutree(fit_2002, k=3)
# Дополним точечный слой данными о принадлежности к кластерам
settlements_2002@data %>%
mutate(clust_3 = clust_3_2002,
clust_6 = clust_6_2002) -> settlements_2002@data
clust_18_2002 <- cutree(fit_2002, k = 18)
# Дополним точечный слой данными о принадлежности к кластерам
settlements_2002@data %>%
mutate(clust_18 = clust_18_2002) -> settlements_2002@data
# Сохраним данные в новую переменную и очистим от лишних столбцов
df <- settlements_2002@data
df %>%
select(-cohort1981, -cohort1990, -cohort2002,
-trend_1981to1990, -trend_1990to2002,
-rel1981to1990, -rel1990to2002, -rel2002to2010) -> df
View(df)
df %>%
group_by(clust_18) %>%
mutate(pop2002 = sum(Census2002), pop2010 = sum(Census2010),
pop2010to2002_rel = pop2010/pop2002*100,         # отношение населения в 2010 году к населению в 2002
max_pop = max(Census2002),                       # величина крупнешего н.п.
mean_pop = mean(Census2002),                     # средний размер н.п.
median_pop = median(Census2002),                 # медианный размер н.п.
sum_pop = sum(Census2002)) %>%                   # сумма населения кластера
select(clust_6, clust_18, pop2002, pop2010, pop2010to2002_rel, mean_pop,median_pop, max_pop, sum_pop) %>%
unique() -> clusters_18_metrics                         # Сохраним результат в новый data.frame
View(clusters_18_metrics)
# Создадим переменные
clusters_18_metrics$variation_2002 <- NA_real_
clusters_18_metrics$variation_2010 <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Calculate variation (standart deviation(x)/mean(x))
# 2002
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$variation_2002 <-
sd(settlements_temp$Census2002, na.rm = T)/mean(settlements_temp$Census2002, na.rm = T)
# 2010
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$variation_2010 <-
sd(settlements_temp$Census2010, na.rm = T)/mean(settlements_temp$Census2010, na.rm = T)
}
# Calculate the difference in variance between 2002 and 2010 (темпы сжатия расселения)
clusters_18_metrics %>%
mutate(variation_dif = variation_2010/variation_2002*100) ->
clusters_18_metrics
# Темпы сжатия расселения vs общая динамика населения
clusters_18_metrics %>%
ggplot(aes(y=variation_dif, x=pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
# geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000), trans = "sqrt",
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика территориальной\nдифференциации расселения", breaks = seq(100, 115, 5),
limits = c(100,115))+
scale_x_continuous(name = "Динамика населения (%)")
# Темпы сжатия расселения vs средний размер населенных пунктов
clusters_18_metrics %>%
ggplot()+
geom_point(aes(y=mean_pop, x=variation_dif))+
geom_smooth(aes(y=mean_pop, x=variation_dif), method = "glm")+
scale_y_continuous(trans = "log")+
scale_x_continuous(name = "Изменение вариации")
clusters_18_metrics$dist2Tyumen <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Subset distance matrix: by row - cluster members, by column - Tyumen
distances_to_Tyumen <- dist_matrix_2002[select_condition, df$ShortName == "г. Тюмень"]
# Weight by population proportion
res <- sum(distances_to_Tyumen * settlements_temp$Census2002/sum(settlements_temp$Census2002))
# Save to res cell
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$dist2Tyumen <- res
}
# 3.4.1. Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=dist2Tyumen/1000, y=pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000),
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика населения (%)")+
scale_x_continuous(name = "Расстояние от центра кластера (км)")
View(clusters_18_metrics)
df %>%
group_by(clust_18) %>%
mutate(pop2002 = sum(Census2002), pop2010 = sum(Census2010),
pop2010to2002_rel = pop2010/pop2002*100,         # отношение населения в 2010 году к населению в 2002
max_pop2002 = max(Census2002),                       # величина крупнешего н.п.
mean_pop2002 = mean(Census2002),                     # средний размер н.п.
median_pop2002 = median(Census2002),                 # медианный размер н.п.
sum_pop2002 = sum(Census2002)) %>%                   # сумма населения кластера
select(clust_6, clust_18, pop2002, pop2010, pop2010to2002_rel, mean_pop,median_pop, max_pop, sum_pop) %>%
unique() -> clusters_18_metrics                         # Сохраним результат в новый data.frame
df %>%
group_by(clust_18) %>%
mutate(pop2002 = sum(Census2002), pop2010 = sum(Census2010),
pop2010to2002_rel = pop2010/pop2002*100,         # отношение населения в 2010 году к населению в 2002
max_pop2002 = max(Census2002),                       # величина крупнешего н.п.
mean_pop2002 = mean(Census2002),                     # средний размер н.п.
median_pop2002 = median(Census2002),                 # медианный размер н.п.
sum_pop2002 = sum(Census2002)) %>%                   # сумма населения кластера
select(clust_6, clust_18, pop2002, pop2010, pop2010to2002_rel, mean_pop2002, median_pop2002, max_pop2002, sum_pop2002) %>%
unique() -> clusters_18_metrics                         # Сохраним результат в новый data.frame
# Создадим переменные
clusters_18_metrics$variation_2002 <- NA_real_
clusters_18_metrics$variation_2010 <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Calculate variation (standart deviation(x)/mean(x))
# 2002
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$variation_2002 <-
sd(settlements_temp$Census2002, na.rm = T)/mean(settlements_temp$Census2002, na.rm = T)
# 2010
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$variation_2010 <-
sd(settlements_temp$Census2010, na.rm = T)/mean(settlements_temp$Census2010, na.rm = T)
}
# Calculate the difference in variance between 2002 and 2010 (темпы сжатия расселения)
clusters_18_metrics %>%
mutate(variation_dif = variation_2010/variation_2002*100) ->
clusters_18_metrics
?estimate_betweenness
# Создадим переменные
clusters_18_metrics$connectivity <- NA_real_
?shortest.paths
i <- 1
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Subset graph
# Extract the verticies
temp_verticies <- shortest_paths(res_graph_2002, from = settl_index_2002[select_condition],
to = settl_index_2002[select_condition]) %>%
.$vpath %>%
unlist()
temp_verticies
# Create subgraph
temp_graph <- induced_subgraph(res_graph_2002, vids = temp_verticies) %>%
simplify()
plot(temp_graph)
# Create subgraph
induced_subgraph(res_graph_2002, vids = temp_verticies) -> temp_graph
plot(temp_graph)
?simplify
cetr_betw
?centr_betw
select_condition
settl_index_2002[select_condition]
temp_verticies
temp_graph
temp_graph %>% simplify() -> temp_graph
temp_graph
print(temp_graph)
summary(temp_graph)
