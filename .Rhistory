clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_pop2010to2002_rel))+
geom_point(aes(size = CL6_mean_pop2002))+
geom_smooth(method = "loess")+
geom_text(aes(x = CL6_density, y = CL6_pop2010to2002_rel - 1, label = clust_6))
# Quick explorative analysis:
# PopDynamics vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_pop2010to2002_rel))+
geom_point(aes(size = CL6_mean_pop2002))+
geom_smooth(col = "grey")+
geom_text(aes(x = CL6_density, y = CL6_pop2010to2002_rel - 1, label = clust_6))
# Var_dif vs Density
clusters_18_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_variance_fif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_density, y = CL6_variance_fif + 0.5,  label = clust_6))
# Var_dif vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_variance_fif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_density, y = CL6_variance_fif + 0.5,  label = clust_6))
# Var_dif vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_density, y = CL6_variance_fif + 0.5,  label = clust_6))
# Var_dif vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_density, y = CL6_variance_dif + 0.5,  label = clust_6))
View(df)
# Quick explorative analysis:
# PopDynamics vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_pop2010to2002_rel))+
geom_point(aes(size = CL6_mean_pop2002))+
geom_smooth(col = "grey")+
geom_text(aes(x = CL6_density, y = CL6_pop2010to2002_rel - 1, label = clust_6))
# Quick explorative analysis:
# PopDynamics vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_pop2010to2002_rel))+
geom_point(aes(size = CL6_mean_pop2002))+
# geom_smooth(col = "grey")+
geom_text(aes(x = CL6_density, y = CL6_pop2010to2002_rel - 1, label = clust_6))
# Betweenness Centralisation
# Create column
clusters_6_metrics$CL6_centr_betw <- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$centr_betw <- centr_betw(temp_graph, normalized = T)$centralization
}
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]
# Betweenness Centralisation
# Create column
clusters_6_metrics$CL6_centr_betw <- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_centr_betw <- centr_betw(temp_graph, normalized = T)$centralization
}
View(clusters_6_metrics)
View(df)
# Централизацию по близости
# Создадим переменную
clusters_6_metrics$CL6_centr_clo<- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_centr_clo <- centr_clo(temp_graph, normalized = T)$centralization
}
# Quick explorative analysis:
# Var_dif vs centr_betw
clusters_6_metrics %>%
ggplot(aes(x = CL6_centr_betw, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_centr_betw+0.001, y = CL6_variance_dif + 0.5, label = clust_6))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = CL6_centr_clo, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = centr_clo+0.001, y = variation_dif + 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_6_metrics %>%
ggplot(aes(x = CL6_centr_clo, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = centr_clo+0.001, y = variation_dif + 0.5, label = clust_18))
# Var_dif vs centr_betw
clusters_6_metrics %>%
ggplot(aes(x = CL6_centr_clo, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = centr_clo+0.001, y = variation_dif + 0.5, label = clust_6))
# Var_dif vs centr_betw
clusters_6_metrics %>%
ggplot(aes(x = CL6_centr_clo, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_centr_clo+0.001, y = CL6_variance_dif + 0.5, label = clust_6))
clusters_6_metrics$CL6_dist2Tyumen <- NA_real_
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_6_2002 == i
settlements_temp <- df[select_condition,]
# Subset distance matrix: by row - cluster members, by column - Tyumen
distances_to_Tyumen <- dist_matrix_2002[select_condition, df$ShortName == "г. Тюмень"]
# Weight by population proportion
res <- sum(distances_to_Tyumen * settlements_temp$Census2002/sum(settlements_temp$Census2002))
# Save to res cell
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_dist2Tyumen <- res
}
# Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_6_metrics %>%
ggplot(aes(x=CL6_dist2Tyumen/1000, y=CL6_pop2010to2002_rel, col = CL6_centr_betw))+
geom_point(aes(size = CL6_mean_pop2002))+
geom_smooth(method = "glm")+
scale_color_viridis_c()
# Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_6_metrics %>%
ggplot(aes(x=CL6_dist2Tyumen/1000, y=CL6_pop2010to2002_rel))+
geom_point(aes(size = CL6_mean_pop2002))+
geom_smooth(method = "glm")+
scale_color_viridis_c()
# Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_6_metrics %>%
ggplot(aes(x=CL6_dist2Tyumen/1000, y=CL6_pop2010to2002_rel))+
geom_point(aes())+
geom_smooth(method = "glm")+
scale_color_viridis_c()
library(sp)
library(sf)
library(raster)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(igraph)
library(RColorBrewer)
library(tidyr)
library(viridis)
# load the data
load("data/Part2_output.RData")
# 1.1. Сохраним данные в новую переменную и очистим от лишних столбцов
df <- settlements_2002@data
df %>%
select(-cohort1981, -cohort1990, -cohort2002,
-trend_1981to1990, -trend_1990to2002,
-rel1981to1990, -rel1990to2002, -rel2002to2010) -> df
my_subgraph_function <- function(graph, nodes) {
# 1) сохраним в отдельный вектор номера всех вершин, лежащих между н.п.
# shortest_paths() возвращает именованный list длины @to,
# который содержит индексы всех вершин и ребер каждого пути
all_the_verticies <-
shortest_paths(graph = graph,        # igraph object
from = nodes,         # vertex ids from
to = nodes) %>%       # vertex ids to
.$vpath %>%                          # extract list of returned vertex ids
unlist()                             # unlist
# 2) выборка из графа
induced_subgraph(graph = graph,                        # igraph object
vids = all_the_verticies) %>%         # vertex ids
simplify() ->                                        # remove loop and multiple edges
sub_graph
return(sub_graph)
}
# ======================================
# 2.1. Descriptive metrics on population
df %>%
group_by(clust_6) %>%
mutate(CL6_pop2002 = sum(Census2002),                        # 2002 population
CL6_pop2010 = sum(Census2010),                        # 2010 population общая численность населения
CL6_pop2010to2002_rel = CL6_pop2010/CL6_pop2002*100,  # percentage of 2010-population to 2002-population
CL6_max_pop2002 = max(Census2002),                    # the largest settlement's size
CL6_mean_pop2002 = mean(Census2002),                  # mean settlement's size
CL6_median_pop2002 = median(Census2002)) %>%          # median settlement's size
# select the columns we need
select(clust_6, CL6_pop2002, CL6_pop2010, CL6_pop2010to2002_rel,
CL6_max_pop2002, CL6_mean_pop2002, CL6_median_pop2002) %>%
unique() -> clusters_6_metrics    # Save the results into new data.frame
# Create new columns
clusters_6_metrics$CL6_variance_2002 <- NA_real_
clusters_6_metrics$CL6_variance_2010 <- NA_real_
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_6_2002 == i
settlements_temp <- df[select_condition,]
# Calculate variation (standart deviation(x)/mean(x))
# 2002
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_variance_2002 <-
sd(settlements_temp$Census2002, na.rm = T)/mean(settlements_temp$Census2002, na.rm = T)
# 2010
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_variance_2010 <-
sd(settlements_temp$Census2010, na.rm = T)/mean(settlements_temp$Census2010, na.rm = T)
}
# Calculate the difference in variance between 2002 and 2010 (темпы сжатия расселения)
clusters_6_metrics %>%
mutate(CL6_variance_dif = CL6_variance_2010/CL6_variance_2002*100) ->
clusters_6_metrics
# Создадим переменную
clusters_6_metrics$CL6_density <- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_density <- edge_density(temp_graph)
}
# Quick explorative analysis:
# PopDynamics vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_pop2010to2002_rel))+
geom_point(aes(size = CL6_mean_pop2002))+
# geom_smooth(col = "grey")+
geom_text(aes(x = CL6_density, y = CL6_pop2010to2002_rel - 1, label = clust_6))
# Var_dif vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_density, y = CL6_variance_dif + 0.5,  label = clust_6))
# Var_dif vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_variance_dif))+
geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_density, y = CL6_variance_dif + 0.5,  label = clust_6))
# Var_dif vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_variance_dif))+
geom_smooth(method = "glm")+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_density, y = CL6_variance_dif + 0.5,  label = clust_6))
# Betweenness Centralisation
# Create column
clusters_6_metrics$CL6_centr_betw <- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_centr_betw <- centr_betw(temp_graph, normalized = T)$centralization
}
# Централизацию по близости
# Создадим переменную
clusters_6_metrics$CL6_centr_clo<- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_centr_clo <- centr_clo(temp_graph, normalized = T)$centralization
}
clusters_6_metrics$CL6_dist2Tyumen <- NA_real_
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_6_2002 == i
settlements_temp <- df[select_condition,]
# Subset distance matrix: by row - cluster members, by column - Tyumen
distances_to_Tyumen <- dist_matrix_2002[select_condition, df$ShortName == "г. Тюмень"]
# Weight by population proportion
res <- sum(distances_to_Tyumen * settlements_temp$Census2002/sum(settlements_temp$Census2002))
# Save to res cell
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_dist2Tyumen <- res
}
View(clusters_6_metrics)
# ======================================
# 3.1. Descriptive metrics on population
df %>%
group_by(clust_18) %>%
mutate(CL18_pop2002 = sum(Census2002),                        # 2002 population
CL18_pop2010 = sum(Census2010),                        # 2010 population общая численность населения
CL18_pop2010to2002_rel = CL6_pop2010/CL6_pop2002*100,  # percentage of 2010-population to 2002-population
CL18_max_pop2002 = max(Census2002),                    # the largest settlement's size
CL18_mean_pop2002 = mean(Census2002),                  # mean settlement's size
CL18_median_pop2002 = median(Census2002)) %>%          # median settlement's size
# select the columns we need
select(clust_6, clust_18, CL18_pop2002, CL18_pop2010, CL18_pop2010to2002_rel,
CL18_max_pop2002, CL18_mean_pop2002, CL18_median_pop2002) %>%
unique() -> clusters_18_metrics    # Save the results into new data.frame
# ======================================
# 3.1. Descriptive metrics on population
df %>%
group_by(clust_18) %>%
mutate(CL18_pop2002 = sum(Census2002),                        # 2002 population
CL18_pop2010 = sum(Census2010),                        # 2010 population общая численность населения
CL18_pop2010to2002_rel = CL18_pop2010/CL18_pop2002*100,  # percentage of 2010-population to 2002-population
CL18_max_pop2002 = max(Census2002),                    # the largest settlement's size
CL18_mean_pop2002 = mean(Census2002),                  # mean settlement's size
CL18_median_pop2002 = median(Census2002)) %>%          # median settlement's size
# select the columns we need
select(clust_6, clust_18, CL18_pop2002, CL18_pop2010, CL18_pop2010to2002_rel,
CL18_max_pop2002, CL18_mean_pop2002, CL18_median_pop2002) %>%
unique() -> clusters_18_metrics    # Save the results into new data.frame
View(clusters_18_metrics)
View(clusters_18_metrics)
# Create new columns
clusters_18_metrics$CL18_variance_2002 <- NA_real_
clusters_18_metrics$CL18_variance_2010 <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Calculate variation (standart deviation(x)/mean(x))
# 2002
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_variance_2002 <-
sd(settlements_temp$Census2002, na.rm = T)/mean(settlements_temp$Census2002, na.rm = T)
# 2010
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_variance_2010 <-
sd(settlements_temp$Census2010, na.rm = T)/mean(settlements_temp$Census2010, na.rm = T)
}
# Calculate the difference in variance between 2002 and 2010 (темпы сжатия расселения)
clusters_18_metrics %>%
mutate(CL18_variance_dif = CL18_variance_2010/CL18_variance_2002*100) ->
clusters_18_metrics
View(clusters_18_metrics)
# Темпы сжатия расселения vs общая динамика населения
clusters_18_metrics %>%
ggplot(aes(y=CL18_variance_dif, x=CL18_pop2010to2002_rel))+
geom_point(aes(size = CL18_mean_pop2002))+
# geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000), trans = "sqrt",
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика территориальной\nдифференциации расселения", breaks = seq(100, 115, 5),
limits = c(100,115))+
scale_x_continuous(name = "Динамика населения (%)")
# Темпы сжатия расселения vs средний размер населенных пунктов
clusters_18_metrics %>%
ggplot(aes(y=CL18_mean_pop2002, x=CL18_variance_dif))+
geom_point()+
geom_smooth(method = "glm")+
scale_y_continuous(trans = "log")+
scale_x_continuous(name = "Изменение вариации")
# Темпы сжатия расселения vs средний размер населенных пунктов
clusters_18_metrics %>%
ggplot(aes(y=CL18_mean_pop2002, x=CL18_variance_dif))+
geom_point()+
# geom_smooth(method = "glm")+
scale_y_continuous(trans = "log")+
scale_x_continuous(name = "Изменение вариации")
# Создадим переменную
clusters_18_metrics$CL18_density <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_density <- edge_density(temp_graph)
}
View(clusters_18_metrics)
# Quick explorative analysis:
# PopDynamics vs Density
clusters_18_metrics %>%
ggplot(aes(x = CL18_density, y = CL18_pop2010to2002_rel))+
geom_point(aes(size = CL18_mean_pop2002))+
# geom_smooth(col = "grey")+
geom_text(aes(x = CL18_density, y = CL18_pop2010to2002_rel - 1, label = clust_18))
# Quick explorative analysis:
# PopDynamics vs Density
clusters_18_metrics %>%
ggplot(aes(x = CL18_density, y = CL18_pop2010to2002_rel))+
geom_point(aes(size = CL18_mean_pop2002))+
# geom_smooth(col = "grey")+
geom_text(aes(x = CL18_density+0.01, y = CL18_pop2010to2002_rel - 1, label = clust_18))
# Quick explorative analysis:
# PopDynamics vs Density
clusters_18_metrics %>%
ggplot(aes(x = CL18_density, y = CL18_pop2010to2002_rel))+
geom_point(aes(size = CL18_mean_pop2002))+
# geom_smooth(col = "grey")+
geom_text(aes(x = CL18_density+0.001, y = CL18_pop2010to2002_rel - 1, label = clust_18))
# Quick explorative analysis:
# PopDynamics vs Density
clusters_18_metrics %>%
ggplot(aes(x = CL18_density, y = CL18_pop2010to2002_rel))+
geom_point(aes(size = CL18_mean_pop2002))+
# geom_smooth(col = "grey")+
geom_text(aes(x = CL18_density+0.001, y = CL18_pop2010to2002_rel - 0.5, label = clust_18))
View(clusters_6_metrics)
# Var_dif vs Density
clusters_18_metrics %>%
ggplot(aes(x = CL18_density, y = CL18_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL18_mean_pop2002))+
geom_text(aes(x = CL18_density, y = CL18_variance_dif + 0.5,  label = clust_6))
# Betweenness Centralisation (централизация по посредничеству)
# Create column
clusters_18_metrics$CL18_centr_betw <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL6_centr_betw <- centr_betw(temp_graph, normalized = T)$centralization
}
# Betweenness Centralisation (централизация по посредничеству)
# Create column
clusters_18_metrics$CL18_centr_betw <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_centr_betw <- centr_betw(temp_graph, normalized = T)$centralization
}
View(clusters_18_metrics)
# Closeness Centralisation (централизация по близости)
# Create column
clusters_18_metrics$CL18_centr_clo<- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_centr_clo <- centr_clo(temp_graph, normalized = T)$centralization
}
# Quick explorative analysis:
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = CL18_centr_betw, y = CL18_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL18_mean_pop2002))+
geom_text(aes(x = CL18_centr_betw+0.001, y = CL18_variance_dif + 0.5, label = clust_6))
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = CL18_centr_clo, y = CL18_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL18_mean_pop2002))+
geom_text(aes(x = CL18_centr_clo+0.001, y = CL18_variance_dif + 0.5, label = clust_6))
# Создаем пустую переменную
clusters_18_metrics$CL18_centr_clo_m <- NA_real_
for (i in 1:18) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
# Subset distance matrix
temp_dist <- dist_matrix_2002[select_condition, select_condition]
# Calculate vector of closeness centrality ids
res <- apply(temp_dist, MARGIN = 1, FUN = function(x) return(1/sum(x, na.rm = T)))
# Calculate centralisation index
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_centr_clo_m <- sum(max(res)-res)/centr_clo_tmax(nodes = length(res))
}
# Higher density, higher bias
# However, the values quite highly correlate
cor(clusters_18_metrics$CL18_centr_clo_m, clusters_18_metrics$CL18_centr_clo) # 0.83
# Compare with igraph results
clusters_18_metrics %>%
ggplot(aes(x = CL18_centr_clo_m, y = CL18_centr_clo, col = CL18_density))+
geom_point()
clusters_18_metrics$CL18_dist2Tyumen <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Subset distance matrix: by row - cluster members, by column - Tyumen
distances_to_Tyumen <- dist_matrix_2002[select_condition, df$ShortName == "г. Тюмень"]
# Weight by population proportion
res <- sum(distances_to_Tyumen * settlements_temp$Census2002/sum(settlements_temp$Census2002))
# Save to res cell
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_dist2Tyumen <- res
}
# Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=CL18_dist2Tyumen/1000, y=CL18_pop2010to2002_rel))+
geom_point(aes())+
geom_smooth(method = "glm")+
scale_color_viridis_c()
# Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=CL18_dist2Tyumen/1000, y=CL18_pop2010to2002_rel))+
geom_point(aes())+
geom_smooth(method = "glm")
View(clusters_18_metrics)
