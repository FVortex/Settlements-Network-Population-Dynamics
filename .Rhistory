select_condition <- clust_18_2002 == i
# Subset graph
# Extract the verticies
temp_verticies <- shortest_paths(res_graph_2002, from = settl_index_2002[select_condition],
to = settl_index_2002[select_condition]) %>% .$vpath %>% unlist()
# Create subgraph
temp_graph <- induced_subgraph(res_graph_2002, vids = temp_verticies) %>%
simplify()
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centralization <- centr_eigen(temp_graph)$centralization
}
plot(simplify(temp_graph), vertex.size=1)
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = variation_dif))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = variation_dif))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = density))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = tmax))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = pop_max))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = max_pop))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = mean_pop))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = mean_pop))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = median_pop))+
geom_point(aes(size = mean_pop))
# Создадим переменные
clusters_18_metrics$centralization <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Subset graph
# Extract the verticies
temp_verticies <- shortest_paths(res_graph_2002, from = settl_index_2002[select_condition],
to = settl_index_2002[select_condition]) %>% .$vpath %>% unlist()
# Create subgraph
temp_graph <- induced_subgraph(res_graph_2002, vids = temp_verticies) %>%
simplify()
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$centralization <- centr_betw(temp_graph)$centralization
}
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = variation_dif))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = median_pop))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = mean_pop))+
geom_point(aes(size = mean_pop))
pr_cent<-proper_centralities(simplify(temp_graph))
calculate_centralities(simplify(temp_graph))%>%
pca_centralities(scale.unit = TRUE)
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_text(aes(label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.005,label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.001,label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.001, y = pop2010to2002_rel - 2, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.001, y = pop2010to2002_rel - 1, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = mean_pop))+
geom_point()
clusters_18_metrics %>%
ggplot(aes(x = density, y = variation_dif))+
geom_point(aes(size = mean_pop))
clusters_18_metrics %>%
ggplot(aes(x = density, y = variation_dif))+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.001, y = variation_dif - 0.5, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = variation_dif))+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.001, y = variation_dif - 0.2, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = variation_dif))+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.0005, y = variation_dif - 0.2, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = variation_dif))+
geom_smooth()+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.0005, y = variation_dif - 0.2, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_smooth()+
geom_text(aes(x = density + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = variation_dif))+
geom_smooth()+
geom_text(aes(x = density + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_smooth()+
geom_text(aes(x = density + 0.001, y = pop2010to2002_rel - 0.5, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = variation_2002))+
geom_smooth()+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.0005, y = variation_dif - 0.2, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = variation_2002))+
geom_smooth()+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.0005, y = variation_2002 - 0.2, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = density, y = variation_2002))+
# geom_smooth()+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.0005, y = variation_2002 - 0.2, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = variation_2002))+
# geom_smooth()+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.0005, y = variation_2002 - 0.2, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = variation_2002))+
# geom_smooth()+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = density + 0.0005, y = centralization - 0.2, label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = variation_2002))+
# geom_smooth()+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = centralization - 0.2, y = density + 0.0005,  label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = variation_2002))+
# geom_smooth()+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = centralization, y = variation_2002,  label = clust_18))
clusters_18_metrics %>%
ggplot(aes(x = centralization, y = variation_2002))+
# geom_smooth()+
geom_point(aes(size = mean_pop))+
geom_text(aes(x = centralization+0.002, y = variation_2002 - 0.1,  label = clust_18))
library(sp)
library(sf)
library(raster)
library(rgdal)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(shp2graph)
library(igraph)
library(leaflet)
library(RColorBrewer)
library(tidyr)
library(scales)
library(ggdendro)   # визуализация дендрограмм (кластерный анализ)
load("data/Part1_output.RData")
# Define function to repeat rows
rep.row <-function(x,n){
matrix(rep(x,each=n),nrow=n)
}
rep.col <-function(x,n){
matrix(rep(x,each=n),ncol=n)
}
# Create matrices of population sizes
pop_1990_matrix <- rep.row(settlements_1990$Rosstat1990/max(settlements_1990$Rosstat1990), nrow(dist_matrix_1990))
pop_2002_matrix <- rep.row(settlements_2002$Census2002/max(settlements_2002$Census2002), nrow(dist_matrix_2002))
pop_2010_matrix <- rep.row(settlements_2010$Census2010/max(settlements_2010$Census2010), nrow(dist_matrix_2010))
# Calculate distance matrices, weightened by population (_w)
dist_matrix_1990_w <- dist_matrix_1990 * pop_1990_matrix
dist_matrix_2002_w <- dist_matrix_2002 * pop_2002_matrix
dist_matrix_2010_w <- dist_matrix_2010 * pop_2010_matrix
closeness_1990_w <- 1/(dist_matrix_1990_w %>% apply(1, sum))
closeness_2002_w <- 1/(dist_matrix_2002_w %>% apply(1, sum))
closeness_2010_w <- 1/(dist_matrix_2010_w %>% apply(1, sum))
ggplot()+
geom_boxplot(data = data_frame(x = settlements_2002$trend_2002to2010, y = closeness_2002_w),
aes(x = x, y = y))+
scale_x_discrete(name = "тренд")+
scale_y_continuous(name = "Взвешенная по численности населения Closeness Centrality")+
theme(axis.text.x = element_text(size = 14))
# То е самое, но в виде гистограммы
ggplot()+
geom_histogram(data = data_frame(fill = settlements_2002$trend_2002to2010, x = closeness_2002_w),
aes(x = x, fill = fill), position = "identity", alpha = 0.7)
# В виде scatter plot
ggplot()+
geom_point(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w),
aes(x = x, y = y), alpha = 0.7)
# В виде scatter plot
ggplot()+
geom_point(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w),
aes(x = x, y = y), alpha = 0.7)+
geom_smooth()
# В виде scatter plot
ggplot(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w),
aes(x = x, y = y))+
geom_point(alpha = 0.7)+
geom_smooth()
# В виде scatter plot
ggplot(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w),
aes(x = x, y = y))+
geom_point(alpha = 0.7)+
geom_smooth(method = "glm")
# В виде scatter plot - есть явный линейный тренд (!): чем ближе поселение к центру тяжести сети,
# тем выше его динамика населения
ggplot(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w),
aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
ggplot(data = data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w),
aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
ggplot(data = data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w),
aes(x = x, y = y))+
filter(y < 1000) %>%
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w) %>%
filter(y < 1000) %>%
ggplot(aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1981$rel1981to1990, x = closeness_1981_w) %>%
filter(y < 1000) %>%
ggplot(aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w) %>%
filter(y < 1000) %>%
ggplot(aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w) %>%
filter(y < 600) %>%
ggplot(aes(x = x, y = y))+
geom_point(alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w, size = settlements_1990$Rosstat1990) %>%
filter(y < 600) %>%
ggplot(aes(x = x, y = y))+
geom_point(aes(size = size), alpha = 0.6)+
geom_smooth(method = "glm")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w, size = settlements_1990$Rosstat1990) %>%
# filter(y < 600) %>%
ggplot(aes(x = x, y = y))+
geom_point(aes(size = size), alpha = 0.6)+
geom_smooth(method = "glm")+
scale_y_continuous(trans = "log")
data_frame(y = settlements_1990$rel1990to2002, x = closeness_1990_w, size = settlements_1990$Rosstat1990) %>%
filter(y < 600) %>%
ggplot(aes(x = x, y = y))+
geom_point(aes(size = size), alpha = 0.6)+
geom_smooth(method = "glm")
# В виде scatter plot - есть явный линейный тренд (!):
# чем ближе поселение к центру тяжести сети,
# тем выше его динамика населения
ggplot(data = data_frame(y = settlements_2002$rel2002to2010, x = closeness_2002_w,
size = settlements_2002$Census2002),
aes(x = x, y = y))+
geom_point(aes(size = size), alpha = 0.6)+
geom_smooth(method = "glm")
library(sp)
library(sf)
library(raster)
library(rgdal)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(igraph)
library(leaflet)
library(RColorBrewer)
library(tidyr)
library(scales)
library(ggdendro)   # визуализация дендрограмм
library(viridis)
# load the data
load("data/Part1_output.RData")
# 1.1.1 Models
# d_1990 <- as.dist(dist_matrix_1990, diag = F)
d_2002 <- as.dist(dist_matrix_2002, diag = F)
d_2010 <- as.dist(dist_matrix_2010, diag = F)
# fit_1990 <- hclust(d_1990, method="ward.D")
fit_2002 <- hclust(d_2002, method="ward.D")
fit_2010 <- hclust(d_2010, method="ward.D")
# Сut tree into 3 and 6 clusters
# clust_3_1990 <- cutree(fit_1990, k=3)
clust_3_2002 <- cutree(fit_2002, k=3)
clust_6_2002 <- cutree(fit_2002, k=6)
# Дополним точечный слой данными о принадлежности к кластерам
settlements_2002@data %>%
mutate(clust_3 = clust_3_2002,
clust_6 = clust_6_2002) -> settlements_2002@data
clust_18_2002 <- cutree(fit_2002, k = 18)
# Дополним точечный слой данными о принадлежности к кластерам
settlements_2002@data %>%
mutate(clust_18 = clust_18_2002) -> settlements_2002@data
# Сохраним данные в новую переменную и очистим от лишних столбцов
df <- settlements_2002@data
df %>%
group_by(clust_18) %>%
mutate(pop2002 = sum(Census2002), pop2010 = sum(Census2010),
pop2010to2002_rel = pop2010/pop2002*100,         # отношение населения в 2010 году к населению в 2002
max_pop = max(Census2002),                       # величина крупнешего н.п.
mean_pop = mean(Census2002),                     # средний размер н.п.
median_pop = median(Census2002),                 # медианный размер н.п.
sum_pop = sum(Census2002)) %>%                   # сумма населения кластера
select(clust_6, clust_18, pop2002, pop2010, pop2010to2002_rel, mean_pop,median_pop, max_pop, sum_pop) %>%
unique() -> clusters_18_metrics                         # Сохраним результат в новый data.frame
# Создадим переменные
clusters_18_metrics$variation_2002 <- NA_real_
clusters_18_metrics$variation_2010 <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Calculate variation (standart deviation(x)/mean(x))
# 2002
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$variation_2002 <-
sd(settlements_temp$Census2002, na.rm = T)/mean(settlements_temp$Census2002, na.rm = T)
# 2010
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$variation_2010 <-
sd(settlements_temp$Census2010, na.rm = T)/mean(settlements_temp$Census2010, na.rm = T)
}
# Calculate the difference in variance between 2002 and 2010 (темпы сжатия расселения)
clusters_18_metrics %>%
mutate(variation_dif = variation_2010/variation_2002*100) ->
clusters_18_metrics
# Темпы сжатия расселения vs общая динамика населения
clusters_18_metrics %>%
ggplot(aes(y=variation_dif, x=pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
# geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000), trans = "sqrt",
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика территориальной\nдифференциации расселения", breaks = seq(100, 115, 5),
limits = c(100,115))+
scale_x_continuous(name = "Динамика населения (%)")
clusters_18_metrics$dist2Tyumen <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Subset distance matrix: by row - cluster members, by column - Tyumen
distances_to_Tyumen <- dist_matrix_2002[select_condition, df$ShortName == "г. Тюмень"]
# Weight by population proportion
res <- sum(distances_to_Tyumen * settlements_temp$Census2002/sum(settlements_temp$Census2002))
# Save to res cell
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$dist2Tyumen <- res
}
# 3.4.1. Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=dist2Tyumen/1000, y=pop2010to2002_rel))+
geom_point(aes(size = mean_pop))+
geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000),
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика населения (%)")+
scale_x_continuous(name = "Расстояние от центра кластера (км)")
# Lad the data
load("data/settlements.Rdata")
# Lad the data
load("data/settlements.Rdata")
library(sp)
library(sf)
library(raster)
library(rgdal)
library(dplyr)
library(ggplot2)
library(shp2graph)
library(igraph)
library(visNetwork)
# Создадим три набора точек по трем временным срезам,
# отфильтровав поселения: существовавшие на данный момент времени
np[np@data$Rosstat1990 > 0, ] -> settlements_1990
np[np@data$Census2002 > 0, ] -> settlements_2002
np[np@data$Census2010 > 0, ] -> settlements_2010
# Define the CRS
pulkovo1942.GK12 <- "+proj=tmerc +lat_0=0 +lon_0=69 +k=1 +x_0=12500000 +y_0=0 +ellps=krass +units=m +no_defs"
# Load rayouns borders from OSM and remove attributes except the names
rayons <- readOGR("data/MR_polygons.shp") %>% spTransform(CRS(pulkovo1942.GK12))
rayons@data %>% select(name) -> rayons@data
# TO_shapes
hydr_lines <- readOGR("data/Gidrology/Гидрография_линии.shp") %>%
geometry() %>%                                                # keep the geometry only
spTransform(CRS(pulkovo1942.GK12)) %>%
raster::intersect(region) -> hydr_lines
hydr_polygons <- readOGR("data/Gidrology/River_pols.shp") %>%
geometry() %>%                                                # keep the geometry only
spTransform(CRS(pulkovo1942.GK12)) %>%
raster::intersect(region) -> hydr_polygons
# Загрузим исправленный слой
roads_fixed <- readOGR("data/roads_fixed.shp")
# Удалим лишние столбцы
roads_fixed@data %>% select(-cat) -> roads_fixed@data
# 2.1. 1990 год
# Integrate settlements to graph
roads_points_temp <- points2network(ntdata = roads_fixed,            # roads layer
pointsxy = coordinates(settlements_1990),  # points ccordinates
ELComputed = T,                            # calculate and return the length of each edge
approach = 2,
ea.prop = c(0,1,1,1,1,1))                  # keep edge attributes
warnings()
roads_points_temp
# Convert to igraph object
res_graph_1990 <- nel2igraph(roads_points_temp[[1]],      # nodelist
roads_points_temp[[2]],           # edgelist
weight = roads_points_temp[[8]])  # the length of edges (from @ea.prop)
summary(res_graph_1990)
# Save node indexes, accotiated with settlements (we need them later)
settl_index_1990 <- roads_points_temp[[3]]
settl_index_1990
# 2.2. 2002 год
# Integrate settlements to graph
roads_points_temp <- points2network(ntdata = roads_fixed,                      # roads layer
pointsxy = coordinates(settlements_2002),  # points ccordinates
ELComputed = T,                            # calculate and return the length of each edge
approach = 2,
ea.prop = c(0,1,1,1,1,1))                  # keep edge attributes
# Convert to igraph object
res_graph_2002 <- nel2igraph(roads_points_temp[[1]],           # nodelist
roads_points_temp[[2]],           # edgelist
weight = roads_points_temp[[8]])  # the length of edges (from @ea.prop)
# Save node indexes, accotiated with settlements
settl_index_2002 <- roads_points_temp[[3]]
# 2.3. 2010 год
# Integrate settlements to graph
roads_points_temp <- points2network(ntdata = roads_fixed,                      # roads layer
pointsxy = coordinates(settlements_2010),  # points ccordinates
ELComputed = T,                            # calculate and return the length of each edge
approach = 2,
ea.prop = c(0,1,1,1,1,1))                  # keep edge attributes
# Convert to igraph object
res_graph_2010 <- nel2igraph(roads_points_temp[[1]],           # nodelist
roads_points_temp[[2]],           # edgelist
weight = roads_points_temp[[8]])  # the length of edges (from @ea.prop)
# Save node indexes, accotiated with settlements
settl_index_2010 <- roads_points_temp[[3]]
dist_matrix_1990 <-
shortest.paths(res_graph_1990,                                        # igraph object
v = settl_index_1990,                                  # from
# to: use the same indexes, but ordered
to = as.numeric(levels(as.factor(settl_index_1990))))
# Приведем матрицу в соответствие стандартному виду (диагональная ось = 0)
dist_matrix_1990 <- dist_matrix_1990[, match(settl_index_1990,
as.numeric(levels(as.factor(settl_index_1990))))]
# Check
dist_matrix_1990[1:10, 1:10]
# 2.4.2. 2002
dist_matrix_2002 <-
shortest.paths(res_graph_2002,                                        # igraph object
v = settl_index_2002,                                  # from
# to: use the same indexes, but ordered
to = as.numeric(levels(as.factor(settl_index_2002))))
# Приведем матрицу в соответствие стандартному виду (диагональная ось = 0)
dist_matrix_2002 <- dist_matrix_2002[, match(settl_index_2002,
as.numeric(levels(as.factor(settl_index_2002))))]
# 2.4.3. 2010
dist_matrix_2010 <-
shortest.paths(res_graph_2010,                                        # igraph object
v = settl_index_2010,                                  # from
# to: use the same indexes, but ordered
to = as.numeric(levels(as.factor(settl_index_2010))))
# Приведем матрицу в соответствие стандартному виду (диагональная ось = 0)
dist_matrix_2010 <- dist_matrix_2010[, match(settl_index_2010,
as.numeric(levels(as.factor(settl_index_2010))))]
# Удалим временные файлы и сохраним результат
rm(np, roads_points_temp, roads, road_topology_test)
save.image("data/Part1_output.RData")
